---
title: 位运算原理及技巧
---
# 位运算
+ 变成语言中位运算都会变成*__补码__*运算，补码是由模而来的，有个简单公式：
`反码=除符号位全部取反，正数补码 = 正数，负数补码 =～正数补码（反码）+1`

## & 且 
> 同位需要满足&& == true（1） 
```js
	//例：a|b 
	var a = 0b101 //5
	var b = 0b001 //1
	a&b //ob001（1）
```

## | 或
> 同位需要满足|| == true（1） 
```js
	//例：a|b 
	var a = 0b101 //5
	var b = 0b001 //1
	a&b //ob101（5）
```

## ^ 异或
> 同位满足 !== true 
```js
	//例：a|b 
	var a = 0b101 //5
	var b = 0b001 //1
	a^b //ob100（4）
```

## << k 左移
> 向左移动k位，空缺（低，右）位补0
```js
	//例：a|b 
	var a = 0b101 //5
	var b = 0b001 //1
	//这里js中number 是32位，4个字节
	a<<b //ob1010（10）
```

## >> 右移
> 向左移动k位，空缺（高，左）位补最高位（符号位）
```js
	//例：a|b 
	var a = 0b101 //5
	var b = 0b001 //1
	//这里js中number 是32位，4个字节
	a>>b //ob010（2）
```

+ ` Demo时候注意位数溢出，即变为二进制数时候超过32位（js中）`

## 技巧变化
+ 同位a^0,不变 可以记做 a|a a&a
+ 同位a^1,取反 ~a
+ 补码上+*2的n次方*,可以n位开始有一个连续的变位，也就是取反，例：`0b1010+2=0b1100`
+ -1的补码位全是1  0补码位全是0

## 为什么负数要使用补码
+ 因为计算机只有加法，所以 a-b = a+模-b-模=a+b补-模(`模：ob01的模可以看成ob100，在计算机中就看编程语言中实现使用的是几个字节，如js中 4个字节所以就是 2的32次方`)
+ ob01模又可以看成 ob11+1,就是1和数字位相等且都为1再加1,a-b= a+(ob11(*假设b只有两位*)+1-b)-模，即b补=(ob11(*假设b只有两位*)+1-b)
+ 而(ob11(*假设b只有两位*)-b)= ，为什么呢？可以这样看ob11所有位都是1所以减b的时候不需要*__借位__*而且字节数一样，即只需要 0变1，1变0，也就是b取反
+ a-b = a+(～b+1)-模，此时超出位会**舍**掉
+ 解释下**舍** 
	- 正数-正数(a-b)：a>b ，b+b原 === 模，a>b,a原一定大于b原，所以为正数（00 000 010 + 11 111 111 =  1 00 000 001 - 1 00 000 001 = 1）
	 
	- 负数-正数：：最高位是  1(a),1((～b+1)) 即：1+1，需要考虑溢出（10 000 001(-127补)+ 10 000 001 = 1 00 000 010 - 1 0 00 000 000= -（0 1 11 111 110(11 111 111 + 11 111 111)）（可以看出位数不一致时，高位0不能忽略因为它是代表符号位））  

## 位运算应用及推理

+ 推理 ～(x+y) = ~x-y 变号  
```js
//取反 其实就是找模 12为模 3和9就互补数 下面模抽象为1 a-3=a+(12-3)=12=a+9-12
//  ~x-y  就是x补数-y  ～x = 1-(x)
// ～(x+y) 得到的是x+y补数 1-(x-y)
//  1-(x)-y === 1-(x-y) 为true
```

+ 判断奇偶数(a&1或a&0)
```js
		var a = 0b101 //5 
		var b = 0b001 //1
		//注意a是奇数所以最低位一定位1，反之0
		// 注意b为1,所以最低位为1.其他位一定为0
		// 所以a&b除最低位外其他一定为0
		a&b == 1 ? "奇数" : "偶数"
```
+ 取反运算
```js
	var a = 0b101 //5
	~a //-6
	// a为正数所以～a为负数（存上去是补码啦）
	// 相差为1的数补码差就是-1，因为他们只是把之前不相同的位交换
	// 因为 -a的补码 = （~a）+1 所以（~a）= -a的补码 -1 = -(a+1)的补码
	// a为负数 ～a为正数也是补码
	// ～a = ～（～（-a）+1）= ~(~(-a-1))=-(a+1)
```
+  取相反数
```js
	var a = 0b101 //5
	(~a+1)
	// -a的补码 = (~a+1)，
	// a的补码= ~(-a)+1,-a(相反数) =~(a的补码-1) = ~(a-1) = ~a+1 = (a^-1)+1
```
+ 取绝对值
```js
/*
a:为正数 不变  绝对值=a
a:为负数 ～(a补-1)= ～a补+1=绝对值
所以此时的思路就是 a == ～a补+1（a为正数）
a>>31 正数为0 负数为-1
a^(a>>31) 正数不变 负取反
即 ：*/
(a^(a>>31)) - (a>>31)
```